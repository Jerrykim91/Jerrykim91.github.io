---
title: 1.1.Pandas
author: Jerry
date: 2021-10-15 09:00:00 +0800
category: Jekyll #Data Analytics
layout: post
---

<h5><p align="right"> {{ page.date | date_to_string }} </p></h5>
<!-- 코드 상단 :  -->
<a href="https://hits.seeyoufarm.com">
<img align="right" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https://github.com/Jerrykim91/jerrykim91.github.io"/></a> 


<br>

#### 1. Data Analytics - 판다스, Pandas

<br>



#### 주로 쓰는 인코딩 `euc-kr, utf-8, CP949, utf-8-sig`

<br>

## 1. 데이터 로드 방법 


### 1) 포맷팅 형식

```py
path = './data/%s.csv' 
df = pd.read_csv(path %'파일이름')
```

<br>

### 2) os 와 glob을 이용하여 path를 가져와 데이터로드하는 방식

<!-- - os, glob의 자세한 내용은 4장에서! -->

<br>

```py
import os
import glob

## 1번 방법 
# 변수에 경로할당
path = 'C:/data/'
df = pd.read_csv(glob.glob(path+'*')[0])

## 2번 방법 
# 현재 내 경로 
os.getcwd()
# ['C:\\stock']

# 데이터 경로 
dirpaths = glob.glob(os.getcwd()+"/data"+"/*")
# ['C:\\stock/data\\상장법인목록.xls']
df = pd.read_csv(dirpaths[0]) 

# 경로 내에 데이터 리스트 확인 
os.listdir(os.getcwd()+"/data")
# ['상장법인목록.xls']
```
<br>

위 코드는 데이터 개수가 변경되면 수정 해야해야한다는 번거로움이 있다. 

개인적으로 이 방식이 좋은 방식이 아닌 것은 알지만 오타방지용으로 많이 사용한다. 

<!-- ### 3)  -->


<br><br>


## 2. 데이터 확인 


### 1) 기본 정보확인 

```py
# info 
df.info()

# shape   ->  데이터 길이 (인덱스, 컬럼)
df.shape

# columns ->  컬럼종류
df.columns
```

<br>


### 2) 특정 위치 정보 확인 

- 원하는 위치의 컬럼과 인덱스 길이를 확인한다. 

```py 
idxNum = 10        # 인덱스 길이
colsLen = [0,2,-1] # 컬럼 위치값 

# 원하는 위치의 컬럼과 인덱스 길이를 확인 
df.iloc[:idxNum, colsLen]
```
<br>

### 3) 데이터 정보 쉽게 보기 

- 데이터 정보 `dict`에 담기
    굳이 할 필요는 없지만 수시로 정보 찾아보기 불편해서

```py
idx = ['정보', '뜻'] # 컬럼정보
cols_info=dict()
for i,j in zip(train.columns[1:],idx):
    cols_info[i]=j

print('done')
cols_info # 변수에 정보가 담김
```
<br><br>


## 3. 결측값 확인하는 코드 

<br>

### 1) 널값 확인 

```py
# 데이터 프레임의 전체 널값 확인 
df.isnull().sum()

# 결측치인 아이만 출력 
df[df.'컬럼이름'.isnull()==True]

```

<br>

### 2) 널값 확인 및 제거 

```py
cols_info = {
            'patient_id': '환자 ID',
            'sex': '성별',
            'age': '나이',
            'country': '국적'}

# 결측확인 
for col in df.columns:
    print(f'{cols_info[col]} = ', df[col].isnull().sum())

# 결측 비율화
for col in df.columns:
    percent = df[col].isnull().sum() / df[col].shape[0]
    msg = 'column: {:>20}\t Percent of NaN value: {:.2f}%'.format(col, 100 * (percent))
    print(msg)
```


### 3) 널값 치환

```py
# 결측값을 다른 값으로 대체
df.fillna()

# 주로 0을 대입해서 많이 사용함 
df.fillna(0)

# 추가적인 메소드
# method = ffill -> 앞으로 채움
# method = bfill -> 위에서 부터 채움
```

<br>



### 4) 널값 제거

```py
# 결측이 존재 하는 행을 지움 
## 행과 열을 조정 하려면 axis=0 혹은 1로 하면됨
df.dropna()
```

<br>

### 5) 널값 처리 가이드 라인 

```py
col_name = list()
for idx,col in enumerate(df.columns):
    percent = df[col].isnull().sum() / df[col].shape[0]
    if df[col].isnull().sum() != 0: # 결측이 없는것을 제외하고 출력 
        print(cols_info[col])
        if percent <= 0.09:
            msg = 'column: {:>2} | Percent of NaN value: {:.2f}%'.format(col, 100 * (percent))
            print(msg, '# 10% 미만 삭제 or 대치')
        elif  0.1< percent < 0.5:
            msg = 'column: {:>2} | Percent of NaN value: {:.2f}%'.format(col, 100 * (percent))
            print(msg,'# 10~50% Regression or Model based imputation ')
        else:
            msg = 'column: {:>2} | Percent of NaN value: {:.2f}%'.format(col, 100 * (percent))
            print(msg,' # 50% 이상 삭제 대상 ')
    else:
        pass
```

<br><br>


## 4. 이상치 


### 1) 이상치 검출

<br>

```py
import numpy as np

def outliner_iqr(data):
  """
  data = 데이터 프레임
  """
    q1, q3 = np.percentile(data,[25,75])
    iqr = q3-q1
    lower_bound = q1 - (iqr *1.5)
    upper_bound = q3 + (iqr *1.5)

    return np.where((data > upper_bound)|(data < lower_bound))
#  배열로 반환됨
```

<br><br>

## 5. `dict()` 정렬(딕트정렬)


- `list()` 안의 중복값의 개수를 확인하고 중복 수에 따라 순위를 확인하자 한다. 

- 그래서 `dict()`를 이용하여 작업을 진행 
- 리스트안의 중복된 값의 개수


```py
data = dict()
for cnt in allData:
    try: data[cnt] += 1
    except: data[cnt]=1
```

<br>

data는 중복값과 그 중복값의 개수를 보여준다.     

이렇게 만들어진 data를 `sorted(data)` 이용해 정렬한다.      

확인해 보니 defult 값 오름차순이며 keys 기준이라 옵션을 이용해 vaules 기준으로 그리고 내림차순으로 변경한다.      

여기서 오름차순을 내림차순으로 변경하는것은 
`sorted(data,reverse=True)` 를 이용하면 되지만 

keys 기준을 vaules 기준으로 바꾸는것 같이 특정 기준을 변경하는것은 따로 패키지를 이용하여 진행해야한다. 다행히도 번거롭게 설치 할 필요는 없다.

<br>

`import operator` 를 이용하여 진행하면 된다.

operator의 자세한 내용은 [참고](https://docs.python.org/ko/3.7/library/operator.html) 확인해보면된다.   

여기서 `itemgetter()` 안에 들어가는 수는 `0` 은 키 기준 , `1` 값 기준이다. 

임포트를 한 후 이렇게 함수 내부에 파라미터 값을 `key=operator.itemgetter(1)` 으로 지정하면 vaules 기준으로 내림차순의 데이터를 확인 가능하다.         

```py
sorted(data.items(),reverse=True, key=operator.itemgetter(1))
``` 
타이을 확인해보면 `list`로 형식으로 담기게 되는데 인덱싱을 이용하여 원하는 형태로 추출이 가능하다.      

<br><br>

 
## 6.  데이터 프레임 생성 


### 1 ) 보유 데이터 기반으로 데이터 프레임 생성 

- `list`, `dict` 에 담긴 데이터를 기반으로 데이터 프레임 생성 

```py
data = dict() or list()

df = pd.DataFrame(data) # 프레임 생성 

print(df)
```

<br>


### 2 ) 생성, 활용해서 데이터 프레임 생성      

<br>

- 데이터를 생성 혹은 활용해서 데이터 프레임 생성      

- 리스트 컴프리헨션(List Comprehension)을 이용해서  생성

```py
df_data = pd.DataFrame( columns = ("fst","sed","trd") )

df_data_1 = df_data
for i in range(5):
    df_data_1.loc[i] = [(i+1)*(n+1) for n in range(3)]

print(df_data_1)
```

<br>

### 3 ) 데이터 프레임 생성 후 특정 컬럼 추가 

<br>

- 특정 컬럼에 데이터 추가

```py
df_data = pd.DataFrame( columns = ("fst","sed","trd") )

# 특정 컬럼에 데이터 추가 
df_data_2 = df_data
df_data_2.trd = [date]

print(df_data_2)
```

<br><br>

## 7. index 핸들링

### 1) `sort_index()`

- index 기준으로 데이터를 정렬
    - 기본 정렬 방식은 오름 차순 
    - 내림 차순 정렬시에는 

```py
# 오름차순 - 디폴트
df.sort_index()
# 내림 차순 
df.sort_index(ascending=False)
```
<br>

### 2) `reset_index()`

- 모든 index를 초기화 한 후 0부터 오름차순으로 재정렬
    - `drop=True`, `drop=False`

```py
df.reset_index(drop=True)
```
<br><br>


## 8. 컬럼 가지고 놀기


### 1) 컬럼 위치 변경

```py
# 컬럼 위치를 변경 하고자 할 때 
df = df[['컬럼이름1', '컬럼이름2']]
```
<br>

### 2) 컬럼 추가 

```py
# 새로운 컬럼을 추가
df['새컬럼이름1'] = 'WoW'  # 1

# 새 컬럼 0으로 채우기
df.loc[:,'새컬럼이름1'] =  '0'  # 2

# 리스트로 채우기
df.loc[:,'새컬럼이름1'] =  ['같이 들어갈 내용']  # 3
```
<br>

### 3) 컬럼 병합

```py
# 
```

<br>


### 4) 컬럼 이름 변경하기 

```py
# 1. 컬럼 개수를 확인  - 개수에 맞게 바꿔야함
df.columns = ['컬럼이름1', '바꾼이름']  # 컬럼 2개 일 경우 

# 2. rename() func을 이용한 컬럼 이름 변경
df = df.rename(columns={'컬럼이름1': '바꿀이름', '컬럼이름2': '바꿀이름'})
```
<br><br>

## 9. 엑셀 데이터 시트 여러개 일 때 출력 


- 말 그대로 엑셀파일은 하나지만 시트가 여러장일 경우 이 방법을 사용해서 데이터를 로드 할 수 있다.  

```py
# 데이터 시트 여러개 일때 출력 
sheet_Name = [
    '2015 부산 강수량', '2016 부산 강수량',
    '2017 부산 강수량', '2018 부산 강수량',
    '2019 부산 강수량', '2020 부산 강수량' ]

def read_exel(xlse_path, sheet_Name) :
    exel_file = pd.ExcelFile(xlse_path)
    data = exel_file.parse(sheet_Name)
    return data

# data = read_exel(data_path, sheet_Name[])
```

<br><br>

## 10. 저장

- 데이터 프레임을 다양한 형식으로 저장 

### 1) 데이터 프레임 to 시리즈_1(excel)


```py
  # 데이터 프레임을 엑셀의 형태로 저장
  df.to_excel("test.xlsx")
  # 더잇음
```
<br>

### 2) 데이터 프레임 to 시리즈_2(csv)

```py
  # 데이터 프레임을 csv 형태로 저장 
  df.to_csv("test.csv")
 # 더잇음
```
<br>

### 3) 데이터 프레임 to 시리즈_3(json)


```py
  # 데이터 프레임을 json 형태로 저장 
  df.to_json("test.json")
   # 더잇음
```

<br><br>

---

<br>

## Reference <br>

- HashCode &nbsp; : &nbsp;<https://hashcode.co.kr/questions/493/%EC%97%AC%EB%9F%AC%EA%B0%9C-%EB%AC%B8%EC%9E%90%EB%A5%BC-%EA%B8%B0%EC%A4%80%EC%9C%BC%EB%A1%9C-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84-%EC%9E%90%EB%A5%B4%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%B4-%EC%9E%88%EB%82%98%EC%9A%94> <br>

<!-- <br>
<br>

## Practice makes perfect! <br> -->

<!-- - [내용](주소) -->


<!-- 코드 하단 -->
<br>
<script src="https://utteranc.es/client.js"
    repo="Jerrykim91/jerrykim91.github.io"
    issue-term="title"
    label="😎"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>
<br>